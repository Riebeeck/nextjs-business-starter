---
title: "TypeScript Best Practices for Modern Web Development"
date: "2025-09-15"
summary: "Essential TypeScript patterns and practices to write safer, more maintainable code in your web applications."
author: "Riebeeck van Niekerk"
tags: ["TypeScript", "JavaScript", "Best Practices", "Web Development"]
image: "/images/blog/typescript-practices.jpg"
---

# TypeScript Best Practices for Modern Web Development

TypeScript has revolutionized the way we write JavaScript, bringing type safety and better tooling to the ecosystem. Here are some essential best practices I've learned from building production applications.

## 1. Use Strict Mode

Always enable strict mode in your `tsconfig.json`:

```json
{
  "compilerOptions": {
    "strict": true,
    "noImplicitAny": true,
    "strictNullChecks": true,
    "strictFunctionTypes": true
  }
}
```

This catches potential bugs at compile time rather than runtime.

## 2. Avoid the `any` Type

The `any` type defeats the purpose of TypeScript. Instead:

```typescript
// ❌ Bad
function processData(data: any) {
  return data.value;
}

// ✅ Good
function processData(data: unknown) {
  if (typeof data === 'object' && data !== null && 'value' in data) {
    return (data as { value: string }).value;
  }
  throw new Error('Invalid data');
}

// ✅ Better - Use generics
function processData<T extends { value: string }>(data: T) {
  return data.value;
}
```

## 3. Leverage Type Inference

TypeScript is smart - let it infer types when possible:

```typescript
// ❌ Redundant
const name: string = 'John';
const age: number = 30;

// ✅ Better - TypeScript infers the types
const name = 'John';
const age = 30;

// But do annotate function returns for clarity
function getUser(): User {
  return { name, age };
}
```

## 4. Use Interfaces for Object Shapes

Interfaces are perfect for defining object structures:

```typescript
interface User {
  id: string;
  name: string;
  email: string;
  role: 'admin' | 'user';
  createdAt: Date;
}

interface ApiResponse<T> {
  data: T;
  status: number;
  message?: string;
}
```

## 5. Discriminated Unions for Type Safety

Use discriminated unions for handling different states:

```typescript
type LoadingState = {
  status: 'loading';
};

type SuccessState<T> = {
  status: 'success';
  data: T;
};

type ErrorState = {
  status: 'error';
  error: string;
};

type AsyncState<T> = LoadingState | SuccessState<T> | ErrorState;

function handleState<T>(state: AsyncState<T>) {
  switch (state.status) {
    case 'loading':
      return 'Loading...';
    case 'success':
      return state.data; // TypeScript knows data exists
    case 'error':
      return state.error; // TypeScript knows error exists
  }
}
```

## 6. Utility Types Are Your Friends

TypeScript provides powerful utility types:

```typescript
interface User {
  id: string;
  name: string;
  email: string;
  password: string;
}

// Pick only specific fields
type PublicUser = Pick<User, 'id' | 'name' | 'email'>;

// Omit sensitive fields
type SafeUser = Omit<User, 'password'>;

// Make all fields optional
type PartialUser = Partial<User>;

// Make all fields required
type RequiredUser = Required<User>;

// Make all fields readonly
type ImmutableUser = Readonly<User>;
```

## 7. Use `const` Assertions

Const assertions provide more specific types:

```typescript
// Without const assertion
const config = {
  apiUrl: 'https://api.example.com',
  timeout: 5000,
}; // Type: { apiUrl: string; timeout: number }

// With const assertion
const config = {
  apiUrl: 'https://api.example.com',
  timeout: 5000,
} as const; // Type: { readonly apiUrl: "https://api.example.com"; readonly timeout: 5000 }
```

## 8. Type Guards for Runtime Checks

Create type guards for runtime type checking:

```typescript
function isUser(value: unknown): value is User {
  return (
    typeof value === 'object' &&
    value !== null &&
    'id' in value &&
    'name' in value &&
    'email' in value
  );
}

function processValue(value: unknown) {
  if (isUser(value)) {
    // TypeScript knows value is User here
    console.log(value.name);
  }
}
```

## 9. Generic Constraints

Use constraints to make generics more specific:

```typescript
interface HasId {
  id: string;
}

function findById<T extends HasId>(items: T[], id: string): T | undefined {
  return items.find(item => item.id === id);
}

// This works
const user = findById(users, '123');

// This won't compile if items don't have an id
// const invalid = findById(numbers, '123');
```

## 10. Organize Types in Separate Files

Keep your codebase clean by organizing types:

```
types/
  ├── user.ts
  ├── api.ts
  ├── common.ts
  └── index.ts  // Re-export all types
```

```typescript
// types/index.ts
export * from './user';
export * from './api';
export * from './common';

// Usage
import type { User, ApiResponse } from '@/types';
```

## Conclusion

TypeScript is a powerful tool that can significantly improve your code quality and developer experience. By following these best practices, you'll write more maintainable, bug-free code.

Remember: TypeScript is there to help you, not to fight against. Embrace its type system, and you'll wonder how you ever lived without it!

---

*Want to discuss TypeScript? Connect with me on [LinkedIn](https://www.linkedin.com/in/riebeeckvanniekerk/)!*
